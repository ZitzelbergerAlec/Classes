\documentclass[letterpaper,10pt,titlepage]{article}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{alltt}
\usepackage{float}
\usepackage{color}
\usepackage{url}
\usepackage{minted}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}
\geometry{textheight=8.5in, textwidth=6in}

\usepackage{hyperref}

\newcommand{\ignore}[2]{\hspace{0in}#2} %Used for inline comments
\newcommand{\tab}{\hspace*{2em}} %For tabbing

\geometry{textheight=10in, textwidth=7.5in}

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}


%pull in the necessary preamble matter for pygments output
\input{pygments.tex}
\parindent = 0.0 in
\parskip = 0.2 in

%Used for code snippets
\usepackage{listings}
\lstset{ %
	language=C,                % choose the language of the code
	basicstyle=\footnotesize,       % the size of the fonts that are used for the code
	numbers=left,                   % where to put the line-numbers
	numberstyle=\footnotesize,      % the size of the fonts that are used for the line-numbers
	stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
	numbersep=5pt,                  % how far the line-numbers are from the code
	backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
	showspaces=false,               % show spaces adding particular underscores
	showstringspaces=false,         % underline spaces within strings
	showtabs=false,                 % show tabs within strings adding particular underscores
	frame=single,           % adds a frame around the code
	tabsize=4,          % sets default tabsize to 2 spaces
	captionpos=b,           % sets the caption-position to bottom
	breaklines=true,        % sets automatic line breaking
	breakatwhitespace=false,    % sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)}          % if you want to add a comment within your code
}

\def\name{David Merrick}
\def\project{Project 3}
\def\date{5 May, 2013}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs411 ``operating systems''},
  pdftitle = {CS 411 \project},
  pdfsubject = {CS 411 \project},
  pdfpagemode = UseNone
}

\parindent = 0.0 in
\parskip = 0.2 in

\begin{document}
\name

CS 411

\date

\begin{center}
{\LARGE Individual Writeup for \project}
\end{center}

\begin{enumerate} 
\item \emph{What do you think the main point of this assignment is?}
The main points of this assignment were to learn about the Linux crypto API, writing device drivers, and the way memory works in Linux. From my understanding, the final project is to write a device driver for a USB Nerf dart gun, so learning how to write a device driver will be very helpful for this.

\item \emph{How did you approach the problem? Design decisions, algorithm, etc.}

\tab \textbf{Background:} 
\tab Linux is a virtual memory operating system. This means that it abstracts the memory available to each process into a contiguous address space. The kernel manages virtual address spaces and the assignment of real memory to virtual memory. The CPU automatically translates virtual addresses to physical addresses using the Memory Management Unit (MMU)\ignore{source:http://en.wikipedia.org/wiki/Virtual_memory}. On a more specific level, memory in Linux is divided into pages. The kernel treats these pages as the basic unit of memory management\ignore{source:Love pg. 231}. Linux uses a page table to keep track of the mapping between virtual and physical memory addresses.

\tab A block driver provides access to devices that transfer randomly accessible data in fixed-size blocksâ€”disk drives, primarily. The first step taken by most block drivers is to register themselves with the kernel. The function for this task is register\_blkdev (which is declared in <linux/fs.h>). The block driver request method has the following prototype: void request(request_queue_t *queue). This function is called whenever the kernel believes it is time for your driver to process some reads, writes, or other operations on the device\ignore{source: http://lwn.net/images/pdf/LDD3/ch16.pdf}. 

\tab Drivers allow the kernel to interact with hardware. Modules are the mechanism by which the Linux kernel can load and unload object code on demand. Writing modules is very similar to writing a new application, rather than development on the core subsystems of the kernel. This is because modules live in their own files and have predefined entry and exit points. To initialize a module, place a module\_init function at the end of the module file. This ``function" is actually a macro that assigns the initialization function of the module. All of these init functions must have the form ``int my_init(void)" and return 0 on success. Typically, these initialization functions register resources, initialize hardware, allocate data structures, etc. Module\_exit() is a macro that defines a module's exit point. The exit point is invoked when the kernel removes a module from memory. In similar fashion to module\_init(), this macro accepts the exit function of the module. Typically, exit functions free resources, shutdown and reset hardware, and perform other cleanup before returning. Essentially, they undo whatever the module\_init() function did\ignore{source: Love, pg 339}. 

\tab To compile the module, you must edit the Kconfig file. A line needs to be added stating ``config MODULE_NAME," followed by ``tristate <description>." This line is followed by ``default <option>." Option can be one of three states: ``y" if this module should be compiled into the kernel, ``n" if it should not be compiled into the kernel, and ``M" if it should be compiled as a module. You also must edit the Makefile in the directory in which the module is located. Simply add a line that states ``obj-$(CONFIG_MODULE_NAME) += module.o" where ``module.o" should be of the same name as your ``module.c" file.

\tab Once a module is compiled, it still needs to be loaded. This can be done with the insmod module.ko command, where module.ko is the name of the desired module. Similarly, rmmod module.ko is used to remove a module. The modules are located in the /lib/modules/<kernel-version>/kernel/drivers directory. To see what modules have been loaded, one can check sysfs. Sysfs is a virtual filesystem mounted under /sys that provides access to the hierarchy of kernel objects (drivers) that have been loaded.

\tab \textbf{Design:} 

\tab \textbf{Algorithm:} 

\tab \textbf{Code:}

\item \emph{How did you ensure your solution was correct? Testing details, for instance.}

\item \emph{What did you learn?}

\end{enumerate}

%input the pygmentized output of mt19937ar.c, using a (hopefully) unique name
%this file only exists at compile time. Feel free to change that.
%\input{\\\_\\\_mt.h.tex}
\end{document}
